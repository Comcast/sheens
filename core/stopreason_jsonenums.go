// Code generated by jsonenums -type=StopReason; DO NOT EDIT.

package core

import (
	"encoding/json"
	"fmt"
)

var (
	_StopReasonNameToValue = map[string]StopReason{
		"Done":              Done,
		"Limited":           Limited,
		"InternalError":     InternalError,
		"BreakpointReached": BreakpointReached,
	}

	_StopReasonValueToName = map[StopReason]string{
		Done:              "Done",
		Limited:           "Limited",
		InternalError:     "InternalError",
		BreakpointReached: "BreakpointReached",
	}
)

func init() {
	var v StopReason
	if _, ok := interface{}(v).(fmt.Stringer); ok {
		_StopReasonNameToValue = map[string]StopReason{
			interface{}(Done).(fmt.Stringer).String():              Done,
			interface{}(Limited).(fmt.Stringer).String():           Limited,
			interface{}(InternalError).(fmt.Stringer).String():     InternalError,
			interface{}(BreakpointReached).(fmt.Stringer).String(): BreakpointReached,
		}
	}
}

// MarshalJSON is generated so StopReason satisfies json.Marshaler.
func (r StopReason) MarshalJSON() ([]byte, error) {
	if s, ok := interface{}(r).(fmt.Stringer); ok {
		return json.Marshal(s.String())
	}
	s, ok := _StopReasonValueToName[r]
	if !ok {
		return nil, fmt.Errorf("invalid StopReason: %d", r)
	}
	return json.Marshal(s)
}

// UnmarshalJSON is generated so StopReason satisfies json.Unmarshaler.
func (r *StopReason) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("StopReason should be a string, got %s", data)
	}
	v, ok := _StopReasonNameToValue[s]
	if !ok {
		return fmt.Errorf("invalid StopReason %q", s)
	}
	*r = v
	return nil
}
